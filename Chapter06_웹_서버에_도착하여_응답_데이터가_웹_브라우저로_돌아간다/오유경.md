# 6장 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다

핵심 포인트

동작순서


---

## 1. 서버의 개요

<br>

### 1. 클라이언트와 서버의 차이점

- 서버도 클라이언트로부터 전송된 패킷을 받기 위해서 준비 단계를 거쳐야한다.

- 네트워크와 관련된 전체적인 구조는 비슷한 형태를 지니고 있다.

- 하지만 서버는 소켓을 미리 열고 클라이언트의 연결을 기다린다는 점, 여러 클라이언트와 소통해야 한다는 점에서 클라이언트와 차이점을 가지고 있다.

<br>

### 2. 서버 어플리케이션의 구조

- 서버 프로그램에서 다수의 클라이언트와 소켓 통신을 하기 위해서 다음과 같은 구조로 진행한다.

- 서버 프로그램에서 클라이언트의 접속을 기다리는 부분과 클라이언트와 대화를 하는 부분을 나눈다.

- 클라이언트와 대화를 하는 부분은 각 클라이언트와 1대1로 대화를 한다. 따라서 대화가 섞이지 않는다.

- 서버 OS의 멀티태스크, 멀티스레드 기능을 사용한 기법이다.

- 이때 접속할 때마다 새로운 연결을 맺는것이 부담이 되면 클라이언트와의 연결 동작을 미리 해놓고 비어있는 소켓에 연결하기도 한다.

<br>

### 3. 서버측의 소켓과 포트 번호

- 서버와 클라이언트의 역할이 고정되어 있는 것이 아니라 여러 형태로 변경되면서 데이터를 송수신 할 수 있기 때문에 좌우대칭으로 실행될 수 있도록 하는 것이 중요하다.

- 하지만 TCP 접속 동작은 좌우 대칭으로 만들기 어렵다. 한쪽이 소켓을 열고 기다리며 다른 한쪽이 연결을 해야하기 때문이다.

- 여기서 접속하는 측이 클라이언트, 접속을 기다리는 측이 서버라고 할 수 있다.

- 웹 소켓의 포트번호

    * 본래 클라이언트는 80이라는 포트의 소켓과 통신을 시작한다. 하지만 접속 한 후 응답에 다른 포트 번호가 들어올 수 없으므로 그대로 80 포트를 사용해야 한다.
    * 이때 같은 포트 번호를 지닌 여러 소켓이 있게되는 문제가 발생한다.
    * 다음 패킷이 왔을 때 헤더의 포트번호로 통신 중인 소켓을 식별할 수 없기 때문이다.
    * 따라서 소켓을 지정할 때 다음 4가지 정보를 모두 조합하여 소켓을 식별한다.
        클라이언트 IP주소
        클라이언트 포트 번호
        서버 IP주소
        서버 포트 번호
    * 그렇다면 왜 디스크립터가 필요할까 ? (위 4가지 정보로 소켓을 식별할 수 있는데)
    * 접속을 대기할 때는 아직 클라이언트 소켓이 지정되지 않았으므로 정보가 없다.
    * 또한 디스크립터 하나로 소켓을 식별하는 것이 더 간단하다.

<br>

---

## 2. 서버의 수신동작

<br>

### 1. LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다

- LAN 어댑터에서 수신하여 디지털 데이터로 바꾼다. (클록 신호를 추출하여 데이터를 0101의 형태로 바꾼다)

- FCS를 통해 패킷의 오류 유무를 검사한다. 오류가 있다면 패킷을 폐기한다.

- MAC헤더의 수신처가 본인인지 확인한다.

- 이더넷은 LAN 전체에 신호를 흘리고 상대를 찾는 형태이기 때문에 올바른 패킷이 아니더라도 도착할 수 있기 때문이다.

- 변환된 디지털 데이터를 LAN 어댑터 내부의 버퍼 메모리에 저장한다. (여기까지 LAN의 MAC 부분이 담당한다)

- LAN 어댑터에서 CPU에게 인터럽트로 패킷이 도착했다는 사실을 알린다.

- LAN 드라이버는 LAN 어댑터의 버퍼 메모리에서 수신한 패킷을 추출하여 프로토콜을 판별하고 적합한 프로토콜 처리 소프트웨어를 호출한다. (TCP/IP 면 해당 프로토콜을 호출하여 패킷을 건낸다)

<br>

### 2. IP 담당 부분의 수신 동작

- IP 담당은 IP 헤더를 점검하고 수신처가 본인 IP인지 확인한다.

- 서버가 라우터와 같이 패킷을 중개하는 역할일 수 있으므로 본인에게 온 패킷이 아닐수도 있다. 이 경우에는 패킷에 쓰인 수신처 IP 주소로 패킷을 중개해야한다.

- IP 담당에서는 fragmentation을 통해서 패킷이 분할되었는지 조사하고 그렇다면 패킷을 일시적으로 메모리에 저장하고 패킷이 모두 모이면 복원한다.

- IP 헤더의 프로토콜 번호를 조사하여 해당 부분에 패킷을 건내준다.(06이면 TCP 담당, 11이면 UDP 담당 등등)

<br>

### 3. TCP 담당 부분이 접속 패킷을 수신했을 때의 동작

- 만일 도착한 패킷의 SYN 컨트롤비트가 1이라면 접속 동작의 패킷이다.

- 접속을 접수하는 동작을 실행한다.

- 포트 번호를 조사하여 해당 포트 번호와 일치하는 접속 대기 소켓이 있는지 확인한다.

- 만일 없다면 오류이므로 오류 패킷을 클라이언트에게 반환한다.

- 접속 대기 소켓을 찾으면 소켓을 복사하여 새로운 소켓을 만들고 송신처IP주소, 포트번호, 시퀀스 초기값, 윈도우 값등 필수 정보를 기록한다.

- 패킷을 받았다는 ACK 번호, 서버의 시퀀스 초기값, 수신 버퍼 빈 용량인 윈도우 값 등을 기록한 TCP 헤더를 만들고 IP 담당에 의뢰하여 반송한다.

- 패킷이 잘 도착하면 ACK 번호가 돌아와 접속이 완료된다.

<br>

### 4. TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작

- 서버측에 같은 포트 번호를 가진 소켓이 많으므로 앞에서 말한 4가지 정보로 적절한 소켓을 찾는다.

- 해당 소켓에 기록된 정보들을 통해 올바르게 데이터 송수신이 이루어지고 있는지 확인한다.

- 시퀀스 번호, 데이터 조각의 길이 등등을 확인한다.

- 패킷에서 추출된 데이터를 수신 버퍼에 저장한다.

- 데이터를 수신하면 수신 응답용 TCP 헤더를 만들고 수신 패킷에 시퀀스 번호와 데이터 길이로 얻은 ACK 번호를 기록하고 IP 담당에 넘겨 클라이언트에게 반송한다.

- 수신 버퍼에 기록된 데이터들은 소켓 라이브러리의 read 함수 호출을 통해 어플리케이션에 넘겨진다.
어플리케이션에서 http 리퀘스트 메시지 내용을 조사하고 브라우저에서 데이터를 반송한다.

<br>

### 5. TCP 담당 부분의 연결 끊기 동작

- 어느 쪽(클라이언트 or 서버) 에서든 연결 끊기 동작에 들어가도 상관없다.

- HTTP 1.0 이라면 서버에서 연결 끊기 동작을 시작한다.

- 서버에서 close 함수를 호출하고 FIN 1로 설정한 TCP 헤더를 클라이언트에게 보낸다.

- 클라이언트도  close 를 호출하고 FIN 1로 설정하여 반송하고 ACK도 보낸다.

- 잠시 기다렸다가 소켓을 말소한다.

<br>

---

## 3. 웹 서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다.

<br>

### 1. 조회의 URI를 실제 파일명으로 변환한다

- http 요청 메세지의 메소드와 URI에 따라서 웹 서버 내부의 동작이 달라진다.

- URI에 적힌 경로에 따라서 데이터를 얻어 응답하는 것이다.

- 하지만 이 데이터를 반드시 디스크에서 읽는 것은 아니다.

- URI에 기록된 경로명의 파일을 읽어오면 디스크의 파일이 전부 노출되기 때문에 무방비해진다.

- 해결 방법으로 웹 서버에 공개하는 디렉토리를 디스크의 실제 디렉토리가 아니라 가상으로 만든 디렉토리 구조를 사용하도록 한다.

- 웹 어플리케이션 내부에서 가상으로 설정한 디렉토리와 실제 데이터를 대응하여 해당 데이터를 반송하도록 한다.

- 만일 브라우저에서 보낸 URI에 마지막 파일명이 생략되면 default로 설정된 파일명이 추가되어서 화명에 표시된다.
ex. index.html

<br>

### 2. CGI (Common Gateway Interface) 프로그램을 작동하는 경우

- 만일 파일 내용에 HTML 문서나 화상데이터면 해당 데이터를 그대로 응답하면 된다.

- 하지만 만일 문서 등이 아니라 프로그램 파일의 이름을 쓸 수도 있다.

- 파일의 내용을 그대로 반송하는 것이 아니라 해당 프로램을 작동시켜 출력하는 데이터를 반송해야 한다.

- 여러 프로그램 유형이 있고 각 유형에 따라서 동작 방식은 상이하다.

- 단순 문서를 요청하는 경우와 위에서 말한 프로그램을 동작시켜서 데이터를 얻는 요청 메세지의 형태가 다르다.

- 요청 메세지 안에 처리하고자 하는 데이터를 넣어서 보낸다.

- 예를 들어서 GET 요청일 경우 query params를 POST 요청일 경우 request body에 데이터가 추가되서 요청 메세지가 온다.

- 해당 요청 메세지가 온다면 웹 서버는 다음과 같이 동작한다.

- 먼저 URI에 적힌 파일명을 보고 프로그램인지 확인한다.
ex. .cgi, php 등등

- 프로그램이라면 해당 프로그램을 작동시키도록 OS에 의뢰한다.

- 데이터를 처리한 후 출력 데이터를 웹 서버에 돌려준다. 해당 데이터는 Html 태그를 내장한 문서이므로 이것을 응답 메세지로 클라이언트에 반송한다.

<br>

### 3. 웹 서버로 수행하는 액세스 제어

- 웹 서버에서는 데이터를 특정 조건에 따라서 액세스를 제어할 수 있다.

- 예를 들어 회원 정보에서 특정 조건으로 동작을 금지시킬 수 있다.

- 이때 사용되는 정보는 다음 3가지 이다.
    * 클라이언트 주소
    * 클라이언트 도메인명
    * 사용자명과 패쓰워드

- 이 조건을 판단하여 액세스가 허가된 경우에만 파일을 읽거나 프로그램을 실행하도록 할 수 있다.

    * 클라이언트 IP 주소가 조건이라면 accept로 접속했을 때 점검한다.
    * 클라이언트 도메인명이면 클라이언트 IP주소로 DNS 서버를 이용해 조사한다.
    * 요청을 받은 웹 서버는 DNS 서버로 요청을 보내 도메인명을 조사한다.
    * 도메인명을 응답 받으면 해당 도메인 명의 IP가 클라이언트의 송신처 IP와 동일한지 이중으로 확인한다.
    * 사용자명과 패쓰워드를 입력하여 액세스를 제어하기도 한다.

<br>

### 4. 응답 메세지를 되돌려 보낸다.

- 최초 클라이언트가 요청 메세지를 웹 서버에 응답하는 동작과 동일하다.

- 웹 서버가 소켓 라이브러리의 write 함수를 호출하여 응답 메세지를 프로토콜 스택에 건내준다.

- 어느 소켓을 사용하여 통지할 지 디스크립터를 통지하여 상대를 지정한다.

- 해당 패킷이 프로토콜 스택에 의뢰되어 응답된다.

<br>

---

## 4. 웹 브라우저가 응답 메시지를 받아 화면에 표시한다

<br>

### 1. 응답 데이터의 형식을 보고 타입을 판단한다

- 응답 메시지에 저장된 데이터가 어떤 종류인지 조사한다.

- 문장, 화상, 음성, 영상 등등

- 응답 메시지의 헤더에 Content-Type을 통해 데이터의 종류를 쓰도록 한다.

- MIME 사양으로 그 종류가 규정되어 있다.

- 데이터의 종류가 text라면 어떤 문자 코드를 사용해야하는지 charset을 통해서 판단한다.

- Content-Encoding 을 통해 헤더의 필드 값을 조사한다.

- 압축 기술이나 부호화 기술에 따라서 변환 여부를 알아야 한다.

- 요청 파일의 확장자를 통해서 데이터를 판단하기도 한다.

<br>

### 2. 브라우저 화면에 웹 페이지를 표시하여 액세스를 완료한다

- HTML의 경우 그 태그의 의미를 해석하여 OS가 어느 위치에 어떻게 표시할지 지시한다.

- JPEG나 GIF 형식은 압축을 풀고 건네준다.

- 관련된 응답 데이터 중 소프트웨어 어플리케이션 데이터는 해당 데이터를 호출하여 화면에 표시될 수도 있다.
