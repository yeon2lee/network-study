# STORY 01 서버의 개요

## 1. 클라이언트와 서버의 차이점

- 서버는 여러 준비 동작을 통해 클라이언트의 패킷을 수용할 수 있는 상태가 된다.
- 클라이언트에서 접속 동작을 수행하고, 서버는 해당 접속을 기다린다.
- 서버의 경우 다수의 클라이언트를 대응할 수 있어야 한다.

## 2. 서버 애플리케이션의 구조

- 서버는 클라이언트 접속 부분과 접속을 기다리는 부분을 분리하여 다수의 클라이언트를 관리한다.
    - 클라이언트가 접속할 때마다 접속 부분을 새로 생성하여 연결한다.
- 이렇게 매번 새로운 프로그램을 생성할 경우 성능이 낮아져, 일부 미리 생성 후 할당하는 방법도 있다.

## 3. 서버측의 소켓과 포트 번호

- TCP 동작은 양측에서 데이터 송수신이 가능하므로, 송수신으로 서버와 클라이언트를 구분하면 안된다.
- 단, 서버와 클라이언트는 ‘접속 동작’ 의 차이가 있어 이를 통해 구분할 수 있다.
    - 서버는 접속을 기다리며, 클라이언트는 접속을 수행한다.
- Socket 라이브러리를 호출하는 과정은 다음은 차이가 있다.
    - 클라이언트 : 소켓 작성 → 접속 → 송수신 → 연결 끊기
    - 서버 : 소켓 작성 → 접속 대기(listen) → 접속 접수(accept) → 송수신 → 연결 끊기
        - accept : 패킷이 아직 도착하지 않았으면 대기, 도착 후 접수 동작 수행
- **서버는 접속 대기 상태의 소켓을 생성 후 클라이언트 접속 시 대기 상태의 소켓을 복사하여 접속 접수 상태의 소켓을 생성한다.**
    - 대기 상태 소켓을 그대로 사용하면 소켓의 정보가 소실된다.
- 소켓을 식별하기 위해 디스크립터라는 정보를 활용한다.
    - 서버는 다수의 소켓을 관리해야 하기 때문에 소켓을 포트 번호로 구분할 경우 새로 만드는 소켓마다 포트 번호를 바꾸어주어야 한다.
    - 그러나 클라이언트에서 요청한 포트 번호와 실제 응답하는 포트 번호가 다를 경우 올바르게 동작되었는지 판단하기 어렵다.
    - 따라서 포트 번호로 소켓을 구분하기 위해서는 다음과 같은 정보를 모두 확인해야 한다.
        - 클라이언트 IP, PORT, 서버의 IP, PORT
    - 하지만 소켓 생성 직후 즉, 접속하지 않은 상태에서는 위의 정보가 존재하지 않으므로 소켓을 식별할 수 없다.
    - 따라서 별도의 식별자인 디스크립터를 사용한다.

# STORY 02 서버의 수신 동작

## 1. LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다

- 서버의 수신 동작은 클라이언트와 동일하다.
- LAN 어댑터에서 패킷 신호를 수신하고 디지털 데이터로 변환한다.
    - 패킷의 신호 = 디지털 데이터 + 클록 신호
    - 프리앰블을 이용하여 클록 신호를 판단하고 추출한다.
    - FCS(프레임 체크 시퀀스) 를 이용하여 데이터가 모두 올바르게 전송되었는지 확인한다.
- MAC 헤더의 수신처 MAC 주소를 조사한다.
    - 오류 검사 후 MAC 주소를 조사하여 본인에게 온 것이 맞는지 확인한다.
    - LAN 어댑터 내부의 버퍼 메모리에 저장한다. (MAC 부분이 실행)
- 수신 과정을 CPU 에게 알린다.
    - CPU 는 다른 일을 처리하고 있었기 때문에 요청이 왔는지 알지 못한다.
    - 인터럽트를 통해 데이터 수신 여부를 알린다.
    - CPU 는 동작을 중단하고 LAN 드라이버로 실행을 전환한다.
- LAN 드라이버가 동작한다.
    - LAN 어댑터 내부 버퍼 메모리의 데이터를 추출한다.

## 2. IP 담당 부분의 수신 동작

- 수신처 IP 주소를 동작하여 본인에게 온 것이 맞는지 확인한다.
- IP 헤더를 조사하여 분할된 패킷인지 확인한다.
    - 분할되지 않았을 경우 그대로 진행한다.
    - 분할되었을 경우 나머지 패킷이 도착하기 전까지 메모리에 저장 후 조립하여 원복한다.
- IP 헤더의 프로토콜 번호 항목을 조사하여 적절한 프로토콜 계층에게 전달한다. (TCP)

## 3. TCP 담당 부분이 접속 패킷을 수신했을 때의 동작

- IP 계층까지는 모든 패킷이 동일하나 TCP 계층부터는 동작 과정에 따라 다르다.
- 접속 동작의 패킷의 경우 SYN 컨트롤비트가 1 이다.
- 포트 번호와 맞는 소켓이 있을 경우 해당 소켓을 복사하여 새로운 소켓을 생성한다.
    - 송신처의 IP 주소, 포트번호, 시퀀스 번호의 초깃값, 윈도우의 값 등 기록
- 클라이언트에게 반송 후 ACK 번호를 수신하면 접속 동작이 끝난다.

## 4. TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작

- 데이터 송수신 단계의 동작 과정이다.
- 패킷에 기록된 송수신 진행 상황과 패킷의 TCP 헤더의 정보가 적절한지 점검한다.
- 수신한 패킷을 수신 버퍼에 데이터 조각을 보관하면 수신 동작이 끝난다.
- 수신 동작이 끝나는 것과 동시에 어플리케이션에게 데이터를 전달한다.
- 제어가 어플리케이션으로 이동하여 어플리케이션 계층에서 데이터를 조사한다.

## 5. TCP 담당 부분의 연결 끊기 동작

- 데이터 송수신 동작이 끝나면 연결 끊기 동작을 수행한다.
- 연결을 끊는 동작은 서버나 클라이언트 어느 한 쪽이 실행하면 연결이 종료된다.
    - Socket 라이브러리의 close 를 호출하고, TCP 담당 부분이 FIN 이라는 컨트롤 비트에 1 을 설정한 TCP 헤더를 만든 후 IP 담당 부분에 의뢰하여 전송한다.
    - 반대 측에게 ACK 번호를 수신하면 종료된다.

# STORY 03 웹 서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다

## 1. 조회의 URI 를 실제 파일명으로 변환한다

- HTTP 리퀘스트 메시지의 URI 를 파싱하여 적절한 처리를 한 후 클라이언트에게 반송한다.

## 2. CGI 프로그램을 작동하는 경우

- CGI : Common Gateway Interface

## 3. 웹 서버로 수행하는 액세스 제어

- 리퀘스트 메시지의 내용에서 데이터 출처를 판단하고, 그곳에서 데이터를 얻어 클라이언트에 반송
- 액세스 제어 : 조건에 따라 액세스 동작 여부를 설정
  - 클라이언트의 주소, 클라이언트의 도메인명, 사용자명과 패스워드 등으로 판단 가능

## 4. 응답 메시지를 되돌려 보낸다

- 클라이언트가 서버에게 리퀘스트 메시지를 보내는 과정과 동일하다.
- 클라이언트와 통신하고 있는 소켓에 통신 정보(수신처 등)를 담고 있으므로 소켓의 디스크립터를 찾아 요청한다.
- 그럼 프로토콜 스택은 데이터를 패킷 크기로 분할하고 헤더를 붙여 송출한다.

# STORY 04 웹 브라우저가 응답 메시지를 받아 화면에 표시한다

## 1. 응답 데이터의 형식을 보고 본질을 파악한다

- LAN 어댑터가 신호로부터 디지털 데이터로 되돌리고, 프로토콜 스택이 분할된 패킷을 모아서 데이터 부분을 추출하여 원래의 응답 메시지로 되돌린 후 브라우저에게 건넨다.
- 브라우저 렌더링 시 데이터의 종류를 파악해야 한다. (Content-Type + 확장자)
  - Content-Type 헤더의 경우 정확하지 않을 수 있어 그 외의 부가 정보를 포함하여 판단한다.
- 압축이나 복호화 되어 있을 경우 원복한다. (Content-Encoding)

## 2. 브라우저 화면에 웹 페이지를 표시하여 액세스를 완료한다

- 기본적인 데이터는 브라우저 자체가 화면 표시 기능을 가지고 있으므로 브라우저 자체에서 화면 표시 동작을 실행한다.
  - HTML 문서, 일반 텍스트, 화상 데이터 등
- HTML : 태그의 의미를 해석하여 문장을 배치하며 화면에 표시한다.
- 화상 데이터 : HTML 태그에 화상 태그를 발견하면 해당 파일을 서버에 요청하여 읽어온다.
